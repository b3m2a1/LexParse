(* ::Package:: *)

(* Autogenerated Package *)

(* ::Subsection:: *)
(*ASTs*)



ConstructASTObject::usage="";


WalkAST::usage="A function for recursively traversing the AST";
FormatAST::usage="A function for making a formatted form of the AST";
TrimASTWhitespace::usage="A little function that uses WalkAST to remove whitespace";


ASTJoin::usage="Joins two ASTObjects";


(* ::Subsection:: *)
(*Nodes*)



ASTNode::usage="Symbolic rep of an AST node";


MakeASTNode::usage="";


GetASTNode::usage="";
GetASTNodeProperty::usage="";


AddASTNode::usage="";
PopASTNode::usage="";
ReplaceASTNode::usage="";


AddASTNodeData::usage="";


CompleteASTNodeQ::usage="Checks whether a Node is complete according to a BlockType";


Begin["`Private`"];


(* ::Subsubsection::Closed:: *)
(*ConstructASTObject*)



ConstructASTObject[]:=
  <|
    "Tree"-><|
      "Children"->{},
      "Body"->None,
      "Root"->True,
      "Token"->None
      |>
    |>;
ConstructASTObject[a_Association]:=
  If[KeyExistsQ[a, "Tree"],
    a,
    <|"Tree"->a|>
    ]


(* ::Subsection:: *)
(*ASTNode*)



(* ::Subsubsection::Closed:: *)
(*AtomicASTNodeQ*)



AtomicASTNodeQ[node_]:=
  Length[node["Children"]]==0;


(* ::Subsubsection::Closed:: *)
(*MakeASTNode*)



iMakeASTNode[children_, body_, token_:None, props:_?AssociationQ:<||>]:=
  Join[
    <|
      "Children"->children,
      "Body"->body,
      "Token"->token,
      "Type"->Lookup[props, "BlockType", "Default"],
      "TypeName"->Lookup[props, "BlockName", None],
      "Root"->False
      |>,
    KeyDrop[props, {"TokenType", "BlockType", "BlockName", "DataFunction"}]
    ]


MakeASTNode//Clear
MakeASTNode["Atomic", data_, token_:None, props:_?AssociationQ:<||>]:=
  iMakeASTNode[{}, 
    If[AssociationQ@data,
      Lookup[data, "DataFunction", (#["Body"]&)]@data,
      data
      ], 
    token, 
    props
    ];
MakeASTNode["Compound", data_, token_:None, props:_?AssociationQ:<||>]:=
  iMakeASTNode[
    Map[
      If[!AssociationQ[#], 
        MakeASTNode["Atomic", #, None, <||>], #]&, 
      Flatten@{data}
      ],
     None,
     token,
     props
     ];
MakeASTNode[data_Association]:=
  If[!KeyExistsQ[data, "Children"],
    MakeASTNode[
      If[data["TokenType"]==="BlockOpener", "Compound", "Atomic"],
      data,
      data["Token"],
      data
      ],
    data
    ];
MakeASTNode[node_ASTNode]:=
  Normal[node];
MakeASTNode[ast_ASTObject]:=
  ast["Tree"]


(* ::Subsubsection::Closed:: *)
(*GetASTNode*)



nodePos[position:{__Integer}]:=
  Prepend[Riffle[position, "Children"], "Children"]


GetASTNode//Clear;
GetASTNode[ast_Association, part:__Integer]:=
  Module[{data},
    data=
      Quiet[
        Check[
          ast[[Sequence@@nodePos[{part}]]],
          $Failed,
          Part::partw
          ],
        Part::partw
        ];
    ASTNode@data/;AssociationQ[data]
    ];
GetASTNode[ast_ASTNode, part:__Integer]:=
  GetASTNode[Normal[ast], part];
GetASTNode[ast_ASTObject, part:__Integer]:=
  GetASTNode[ast["Tree"], part]


(* ::Subsubsection::Closed:: *)
(*ReplaceASTNode*)



ReplaceASTNode[tree_, position:{__Integer}, data_]:=
  ReplacePart[tree, 
    nodePos[position]->MakeASTNode[data]
    ];
ReplaceASTNode[ast_ASTNode, position:{__Integer}, data_]:=
  InterfaceModify[ASTNode,
    ast, 
    Insert[#, ReplaceASTNode[#, position, data], "Children"]&
    ]
ReplaceASTNode[ast_ASTObject, position:{__Integer}, data_]:=
  InterfaceModify[ASTObject,
    ast, 
    Insert[#, ReplaceASTNode[#["Tree"], position, data], "Tree"]&
    ]
ReplaceASTNode[a_, pos_Integer, d_]:=
   ReplaceASTNode[a, {pos}, d]


(* ::Subsubsection::Closed:: *)
(*AddASTNode*)



(* ::Text:: *)
(*
	Basically this needs to be able to determine what the type of data is (syntactically), whether that means it should become an atomic or compound node, and then insert in the AST at the current node position
	
	The tree argument can also actually just be a node
*)



AddASTNode[tree_, data_, position:{__Integer}:{-1}]:=
  AddASTNodeData[tree, MakeASTNode[data]];
AddASTNode[ast_ASTNode, data_, position:{__Integer}:{-1}]:=
  InterfaceModify[ASTNode,
    ast, 
    Insert[#, AddASTNode[#, data, position], "Children"]&
    ]
AddASTNode[ast_ASTObject, data_, position:{__Integer}:{-1}]:=
  InterfaceModify[ASTObject,
    ast, 
    Insert[#, AddASTNode[#["Tree"], data, position], "Tree"]&
    ];
 AddASTNode[a_, d_, pos_Integer]:=
   AddASTNode[a, d, {pos}]


(* ::Subsubsubsection::Closed:: *)
(*AddASTNodeData*)



(* ::Text:: *)
(*
	Little function to add a node to a node or to an AST at the end
*)



AddASTNodeData//Clear
AddASTNodeData[node_Association, data_List, position:{__Integer}:{-1}]:=
  Block[{$wrap},
    With[{pos=Most@nodePos[position]},
      ReplacePart[node, 
        pos->
          Replace[
            Insert[node[[Sequence@@pos]], $wrap[data], position[[-1]]],
            {a___, $wrap[{d___}], e___}:>
              {a, d, e}
            ]
        ]
      ]
    ];
 AddASTNode[node_Association, data_, position:{__Integer}:{-1}]:=
  Insert[node, data, nodePos[position]]


(* ::Subsubsection::Closed:: *)
(*PopASTNode*)



PopASTNode//Clear
PopASTNode[tree_Association, position:{__Integer}:{-1}]:=
  Module[
    {
      pos=nodePos[position],
      data
      },
    data = tree[[Sequence@@pos]];
    {ASTNode[data], Delete[tree, pos]}/;AssociationQ[data]
    ];
PopASTNode[ast_ASTNode, position:{__Integer}:{-1}]:=
  With[{p=PopASTNode[Normal[ast], position]},
    {
      p[[1]],
      InterfaceModify[ASTNode,
        ast, 
        p[[2]]&
        ]
      }/;ListQ[p]
    ];
PopASTNode[ast_ASTObject, position:{__Integer}:{-1}]:=
  With[{p=PopASTNode[ast["Tree"], position]},
    {
      p[[1]],
      InterfaceModify[ASTObject,
        ast, 
        Insert[#, p[[2]], "Tree"]&
        ]
      }/;ListQ[p]
    ];
PopASTNode[a_, d_, pos_Integer]:=
   PopASTNode[a, d, {pos}]


(* ::Subsubsection::Closed:: *)
(*GetASTNodeProperty*)



(* ::Text:: *)
(*
	Only supports a finite number of properties but is where new properties should be put
*)



GetASTNodeProperty[tree_, "ChildCount"]:=
  Length@tree["Children"];
GetASTNodeProperty[tree_, "Children"]:=
  tree["Children"];
GetASTNodeProperty[tree_, "Token"]:=
  tree["Token"];
GetASTNodeProperty[tree_, "BlockType"]:=
  tree["BlockType"];


(* ::Subsubsection::Closed:: *)
(*$ASTNodeTypes*)



$ASTNodeTypes={
  "Default",               (* A standard unstructured node with children *)
  "Complete",              (* A complete atomic node constructed directly when it was parsed *)
  "Operator",              (* A node for a binary operator *)
  {"FixedLength", _},      (* A node with a fixed number of children *)
  {"Delimited", {_, _}},   (* A node bracketed by two token types *)
  {"Structured", {__}}     (* A structured node with a fixed set of token types *)
  };


(* ::Subsubsection::Closed:: *)
(*CompleteASTNodeQ*)



(* ::Subsubsubsection::Closed:: *)
(*Structured*)



CompleteASTNodeQ[node_, {"Structured", blocks:{__}}, strict:True|False:True]:=
  structuredNodeMatchQ[node, blocks, strict];


(* ::Subsubsubsection::Closed:: *)
(*Delimited*)



CompleteASTNodeQ[node_, {"Delimited", s:{_, _}}, strict:True|False:True]:=
  delimitedNodeMatchQ[node, s, strict];


(* ::Subsubsubsection::Closed:: *)
(*FixedLength*)



CompleteASTNodeQ[node_, {"FixedLength", n_}, strict:True|False:True]:=
  Length@GetASTNodeProperty[node, "Children"]==n;


(* ::Subsubsubsection::Closed:: *)
(*Default/Complete*)



CompleteASTNodeQ[node_, "Default"|"Complete", strict:True|False:True]:=
  True;


(* ::Subsubsubsection::Closed:: *)
(*Operator*)



CompleteASTNodeQ[node_, "Operator", strict:True|False:True]:=
  CompleteASTNodeQ[node, {"FixedLength", 1}, strict];


CompleteASTNodeQ[node_, e:Except[True|False], strict:True|False:True]:=
  If[strict,
    PackageRaiseException[
      Automatic,
      
      ]
    ];
CompleteASTNodeQ[node_, strict:True|False:True]:=
  CompleteASTNodeQ[node, node["Type"], strict]


(* ::Subsubsubsection::Closed:: *)
(*structuredNodeMatchQ*)



structuredNodeMatchQ[node_, blocks_, strict:True|False:True]:=
  Block[
    {
      main = GetASTNodeProperty[node, "Token"], 
      n = DeleteCases[#["Token"]&/@GetASTNodeProperty[node, "Children"], None]
      },
    PrependTo[n, main];
    MapThread[
      If[#=!=#2,
        If[strict, 
          PackageRaiseException[Automatic,
            "Expected token '``' got '``'", 
            #2,
            #
            ],
          Return[False, Block]
          ]
        ]&,
      {
        n[[;;Min@{Length@n, Length@blocks}]],
        blocks[[;;Min@{Length@n, Length@blocks}]]
        }
      ];
    Length@blocks==Length@n
    ]


(* ::Subsubsubsection::Closed:: *)
(*delimitedNodeMatchQ*)



delimitedNodeMatchQ[node_, last_, {start_, end_}, strict:True|False:True]:=
  Block[{},
    If[GetASTNodeProperty[node, "Token"]=!=start, 
      If[strict,
        PackageRaiseException[Automatic,
          "Expected opening token `` got `` in delimited pair ('``', '``')",
          start, GetASTNodeProperty[node, "Token"],
          start, end
          ],
        Return[False, Block]
        ]
      ];
    GetASTNodeProperty[last, "Token"]===end
    ];
delimitedNodeMatchQ[node_, {start_, end_}, strict:True|False:True]:=
  delimitedNodeMatchQ[node, 
    GetASTNodeProperty[node, "Children"][[-1]], {start, end}, strict];


(* ::Subsubsection::Closed:: *)
(*ASTNode*)



RegisterInterface[
  ASTNode,
  {"Children"},
  "Constructor"->MakeASTNode,
  "AccessorFunctions"->
    <|
      "Keys"->getKey, 
      "Parts"->GetASTNode
      |>
  ]


(* ::Text:: *)
(*
	I\[CloseCurlyQuote]m putting this here so I can eventually expand upon it if it turns out that OOP for an AST is useful
*)



getKey[ASTNode[a_], k_]:=a[k]


InterfaceMethod[ASTNode]@
  node_ASTNode["Insert"][a__]:=
    AddASTNode[node, a];
InterfaceMethod[ASTNode]@
  node_ASTNode["Pop"][a__]:=
    PopASTNode[node, a];
InterfaceMethod[ASTNode]@
  node_ASTNode["Replace"][pos_, a_]:=
    ReplaceASTNode[node, pos, a];


InterfaceMethod[ASTNode]@
  node_ASTNode["Walk"][a___]:=
    WalkAST[node, a];
InterfaceMethod[ASTNode]@
  node_ASTNode["Format"][a___]:=
    FormatAST[node, a];


(* ::Subsection:: *)
(*AST Functions*)



(* ::Subsubsection::Closed:: *)
(*WalkAST*)



(* ::Text:: *)
(*

We\[CloseCurlyQuote]ll provide like two events?
	- \[OpenCurlyDoubleQuote]EnterNode\[CloseCurlyDoubleQuote]
	- \[OpenCurlyDoubleQuote]ProcessNode\[CloseCurlyDoubleQuote]
	- \[OpenCurlyDoubleQuote]ExitNode\[CloseCurlyDoubleQuote]
	
*)



(* ::Subsubsubsection::Closed:: *)
(*walkASTNodeDF*)



walkASTNodeDF[node_, handlers:{body_, enter_, exit_}]:=  
  Module[{children = node["Children"], res},
    enter[node];
    res=
      If[ListQ@children,
        body[
          walkASTNodeDF[#, handlers]&/@children, 
          node[],
          node["Token"], 
          node
          ],
        body[node["Body"], node["Token"], node]
        ];
    exit[node];
    res
    ];


(* ::Subsubsubsection::Closed:: *)
(*walkASTNodeBF*)



walkASTNodeBF[node_, handlers:{body_, enter_, exit_}]:=  
  Module[{children = node["Children"], res},
    enter[node];
    res=
      If[ListQ@children,
        body[walkASTNodeDF[#, handlers]&/@children, node["Token"], node],
        body[node["Body"], node["Token"], node]
        ];
    exit[node];
    res
    ];


(* ::Subsubsubsection::Closed:: *)
(*WalkAST*)



Options[WalkAST]=
  {
    Method->"DepthFirst"
    };
WalkAST[ast_Association, visitFunctions_,
  ops:OptionsPattern[]
  ]:=
  Module[
    {
      enter=Lookup[visitFunctions, "EnterNode", None],
      exit=Lookup[visitFunctions, "ExitNode", None],
      body=Lookup[visitFunctions, "ProcessNode", #&]
      },
    If[OptionValue[WalkAST, FilterRules[{ops}, Method], Method]==="BreadthFirst",
      walkASTNodeBF,
      walkASTNodeDF
      ][ast, {body, enter, exit}]
    ];
WalkAST[ast_ASTObject, visitFunctions_, ops:OptionsPattern[]]:=
  WalkAST[ast["Tree"], visitFunctions, ops];
WalkAST[ast_ASTNode, visitFunctions_, ops:OptionsPattern[]]:=
  WalkAST[Normal[ast], visitFunctions, ops];


(* ::Subsubsection::Closed:: *)
(*FormatAST*)



Options[FormatAST]=
  {
    "OperatorStyle"->"OperatorStyle",
    "CommandStyle"->"CommandStyle",
    "BlockStyle"->"BlockStyle",
    "SeparatorStyle"->"SeparatorStyle",
    "StringStyle"->"StringStyle",
    "CodeStyle"->"CodeStyle"
    };
FormatAST[ast_, customTokenStyles:_?AssociationQ:<||>, ops:OptionsPattern[]]:=
  Replace[r_RowBox:>RawBoxes[r]]@WalkAST[ast, 
    <|
      "ProcessNode"->
        formatASTBody[
          Join[
            Association[Flatten[{Options[FormatAST], ops}]],
            customTokenStyles
            ]
          ]
      |>
    ]


formatASTBody[styles_][l_List, token_, node_]:=
  Switch[node["BlockType"],
    "Operator",
      Lookup[styles, token, 
        RowBox[Riffle[#, StyleBox[#2, #3]]]&
        ][l, Replace[token, Except[_String]->""], styles["OperatorStyle"]],
    {"Delimited", {token, _}},
      Lookup[styles, token, 
        RowBox[Prepend[#, StyleBox[#2, #3]]]&
        ][l, Replace[token, Except[_String]->""], styles["BlockStyle"]],
    {"Structured", _},
      Lookup[styles, token, 
        RowBox[Prepend[#, StyleBox[#2, #3]]]&
        ][l, Replace[token, Except[_String]->""], styles["CommandStyle"]],
    {"Delimited", {_, token}},
      Lookup[styles, token, 
        Sequence@@Append[#, StyleBox[#2, #3]]&
        ][l, Replace[token, Except[_String]->""], styles["BlockStyle"]],
    "Complete",
      Lookup[styles, token, 
        Sequence@@Map[With[{s=#3},StyleBox[#, s]&], #]&
        ][l, Replace[token, Except[_String]->""], styles["StringStyle"]],
    "Default",
      Lookup[styles, token, 
        RowBox[Append[#, StyleBox[#2, #3]]]&
        ][l, Replace[token, Except[_String]->""], styles["SeparatorStyle"]],
    _,
      Lookup[styles, token, 
        RowBox[Append[#, #2]]&
        ][l, Replace[token, Except[_String]->""], styles["CodeStyle"]]
    ];
formatASTBody[styles_][e_, token_, node_]:=
  formatASTBody[styles][{e}, Replace[token, Except[_String]->""], node]


(* ::Subsubsection::Closed:: *)
(*TrimASTWhitespace*)



trimWhitespace[body_, token_, node_]:=
  If[StringQ@body, 
    If[token===None&&
        StringMatchQ[body, w:Whitespace/;(StringFreeQ[w, "\n"])],
      Nothing(* drop the node if it's literally just padding *),
      ReplacePart[node, 
        "Body"->
          StringReplace[body, 
            {
              " "..->"",
              "\n"..->"\n"
              }
            ]
         ](* otherwise just trim the whitespace *)
      ],
    ReplacePart[node, "Children"->body](* actually applies the pruning on the higher up nodes *)
    ];


TrimASTWhitespace[ast_]:=
  ASTObject@ast@"Walk"[<|"ProcessNode"->trimWhitespace|>]


(* ::Subsubsection::Closed:: *)
(*ASTJoin*)



(* ::Text:: *)
(*
	This is gonna be a somewhat hard one... 
	Gotta figure out how to merge two incomplete ASTs
	If complete obviously just add all the second one\[CloseCurlyQuote]s nodes to the first one.
	
	Probably cleanest to write a RearrangeAST function that will go through and find incomplete nodes
	and then arrange as necessary...
	
	Requires that we move all the AST BlockTypes into the Node API so that they can be checked there. 
*)



End[];



