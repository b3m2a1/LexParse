(* ::Package:: *)

(* Autogenerated Package *)

EBNFRule::usage="";
EBNFSequence::usage="";
EBNFAlternatives::usage="";
EBNFOptional::usage="";
EBNFRepeated::usage="";
EBNFAny::usage="";


BuildEBNFGrammar::usage="";


BuildEBNFGrammarRule::usage="";
BuildEBNFGrammarSymbol::usage="";
BuildEBNFGrammarValue::usage="";


BuildEBNFLexer::usage="";
CollectEBNFTokens::usage="";


BuildEBNFParser::usage="";
CollectEBNFTokenPatterns::usage="";


Begin["`Private`"];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFGrammar*)



(* ::Text:: *)
(*
	I\[CloseCurlyQuote]m implementing this directly from https://www.ics.uci.edu/~pattis/misc/ebnf2.pdf
*)



(* ::Text:: *)
(*We\[CloseCurlyQuote]re gonna have a few special heads here (just because explicit types are useful). These will map very directly onto Mathematica structures (obviously, because Mathematica is implemented using EBNF-type rules).*)



EBNFRule[name_, structure_];
EBNFSequence[seq__];
EBNFAlternatives[alts__];
EBNFOptional[structure_, val_];
EBNFRepeated[structure_];
EBNFAny[];


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarValue*)



BuildEBNFGrammarValue//Clear


normalizeSlots[a_]:=
  a/.Verbatim[Blank][s_Symbol]:>Blank[SymbolName[s]]


BuildEBNFGrammarValue[Verbatim[Alternatives][a__]]:=
  BuildEBNFGrammarValue/@EBNFAlternatives[a]//normalizeSlots;


BuildEBNFGrammarValue[Verbatim[Sequence][a__]]:=
  BuildEBNFGrammarValue/@EBNFSequence[a]//normalizeSlots;
BuildEBNFGrammarValue[Verbatim[PatternSequence][a__]]:=
  BuildEBNFGrammarValue[Sequence[a]];


BuildEBNFGrammarValue[Verbatim[Repeated][a_]]:=
  BuildEBNFGrammarValue/@EBNFRepeated[a]//normalizeSlots;


BuildEBNFGrammarValue[Verbatim[Optional][a_, b_]]:=
  BuildEBNFGrammarValue/@EBNFOptional[a, b]//normalizeSlots;


BuildEBNFGrammarValue[Verbatim[_]|Verbatim[__]|Verbatim[___]]:=
  EBNFAny[];


BuildEBNFGrammarValue[HoldPattern[v_]]:=BuildEBNFGrammarValue[v]
BuildEBNFGrammarValue[e_]:=e;


BuildEBNFGrammarValue~SetAttributes~{HoldAll, SequenceHold};


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarSymbol*)



BuildEBNFGrammarSymbol[s:_Symbol]:=
  {_SymbolName[s]};
BuildEBNFGrammarSymbol[s:_String]:=
  {_s};
BuildEBNFGrammarSymbol[{e_, ops___}]:=
  {BuildEBNFGrammarSymbol[e][[1]], ops};
BuildEBNFGrammarSymbol[e_]:=
  {e};


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarRule*)



BuildEBNFGrammarRule[(Rule|RuleDelayed)[r_, v_]]:=
  With[{sym=BuildEBNFGrammarSymbol[r]},
    EBNFRule[sym[[1]], BuildEBNFGrammarValue[v], Rest[sym]]
    ];
BuildEBNFGrammarRule[e_EBNFRule]:=
  e;
BuildEBNFGrammarRule~SetAttributes~{HoldAll, SequenceHold}


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammar*)



BuildEBNFGrammar[rules:{(_RuleDelayed|_Rule|_EBNFRule)..}]:=
  Module[
    {grammarStructs},
    grammarStructs = BuildEBNFGrammarRule/@rules;
    (* allows us to reuse struct names *)
    <|
      "Rules"->
        Thread[
          EBNFRule[
            grammarStructs[[All, 1]],
            grammarStructs[[All, 2]] //. 
              Map[Verbatim[Replace[#[[1]], {l_, ___}:>l]]->#[[2]]&, grammarStructs],
            grammarStructs[[All, 3]]
            ]
          ]
      |>
    ];
BuildEBNFGrammar[a_Association]:=
  If[KeyExistsQ[a, "Rules"], a, BuildEBNFGrammar[Normal@a]];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFLexer*)



(* ::Subsubsubsection::Closed:: *)
(*CollectEBNFTokens*)



(* ::Text:: *)
(*
	Determines the necessary set of tokens to feed to the tokenizer to build the grammar
*)



$convertEBNFTokenRules=
  Dispatch@
    {
      EBNFAlternatives[a___]:>
        CollectEBNFTokens@{a},
      EBNFSequence[e___]:>
        CollectEBNFTokens@{e},
      EBNFOptional[arg_]:>
       stickyOptional[Value@CollectEBNFTokens[{arg}]],
      EBNFRepeated[arg_]:>
        repeatTokens[CollectEBNFTokens[{arg}], 10],
      EBNFRule[
        name_,
        struct_,
        ops___
        ]:>({name[[1]], ops}->Flatten[CollectEBNFTokens@{struct}, 1]),
      s_String:>s,
      _->Nothing
      };


CollectEBNFTokens[e_EBNFGrammar]:=
  CollectEBNFTokens[e["Rules"]];
CollectEBNFTokens[rules_List]:=
  Replace[rules, $convertEBNFTokenRules, 1];


(* ::Subsubsubsection::Closed:: *)
(*repeatTokens*)



repeatTokens[tok_, n_]:=
  Map[StringRepeat[tok, #]&, Range[n]];
repeatTokens~SetAttributes~Listable;


(* ::Subsubsubsection::Closed:: *)
(*stickyOptional*)



stickyOptional/:
  {a___, stickyOptional[tags_], b:_String|_List, c___}:=
    {a, glomOptional[tags, b], c};
glomOptional[tag_, tok_]:=
  tag<>tok;
glomOptional~SetAttributes~Listable;


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFLexer*)



BuildEBNFLexer[e_EBNFGrammar]:=
  LexerObject[DeleteDuplicates@Flatten@Values@CollectEBNFTokens[e]];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFParser*)



(* ::Subsubsubsection::Closed:: *)
(*CollectEBNFTokenPatterns*)



(* ::Text:: *)
(*
	Need a good way to go from simple rules to the full spec
*)



$convertEBNFPatternRules=
  Dispatch@
    {
      EBNFSequence[start_, EBNFAny[], end_]:>
        {"Delimited", {start, end}},
      EBNFSequence[EBNFAny[], op_, EBNFAny[]]:>
        "Operator",
      EBNFSequence[EBNFAny[], op_]:>
        "Default",
      EBNFSequence[struct:Except[EBNFAny[]]..]:>
        {"Structured", Replace[CollectEBNFTokens[{struct}], {a_, ___}:>a, 1]},
      EBNFRule[
        name_,
        struct_,
        ops___
        ]:>({name[[1]], ops}->Flatten[collectTokenBlockTypes@{struct}, 1]),
      s_String:>s,
      _->Nothing
      };


collectTokenBlockTypes[rules_]:=
  Replace[rules, $convertEBNFPatternRules, 1]


CollectEBNFTokenPatterns[e_EBNFGrammar]:=
  CollectEBNFTokenPatterns[e["Rules"]];
CollectEBNFTokenPatterns[rules_List]:=
  With[
    {
      tokens=Association@CollectEBNFTokens[rules],
      blocks=Association@collectTokenBlockTypes[rules]
      },
   Throw@Flatten@MapIndexed[
      Table[
        <|
          "Token"->t,
          "BlockType"->blocks[#2[[1]]],
          "BlockName"->#2[[1, 1]],
          Sequence@@#2[[1, 2]]
          |>,
        {t, #}
        ]&,
      tokens
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFParser*)



(* ::Text:: *)
(*
	Builds a ParserObject that can handle the specified EBNF grammar
*)



BuildEBNFParser[e_EBNFGrammar]:=
  Module[{lexer=BuildEBNFLexer[e], p},
    p = ParserObject[
      lexer,
      CollectEBNFTokenPatterns[e]
      ];
    InterfaceModify[ParserObject,
      p,
      Append[#, "Grammar"->e]&
      ]
    ]


End[];



