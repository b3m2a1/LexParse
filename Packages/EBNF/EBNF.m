(* ::Package:: *)

(* Autogenerated Package *)

EBNFRule::usage="";
EBNFSequence::usage="";
EBNFAlternatives::usage="";
EBNFOptional::usage="";
EBNFRepeated::usage="";
EBNFAny::usage="";
EBNFStringData::usage="";
EBNFExcept::usage="Only has meaning in the context of escape character";


BuildEBNFGrammar::usage="";


BuildEBNFGrammarRule::usage="";
BuildEBNFGrammarSymbol::usage="";
BuildEBNFGrammarValue::usage="";


BuildEBNFLexer::usage="";
CollectEBNFTokens::usage="";


BuildEBNFParser::usage="";
CollectEBNFTokenPatterns::usage="";


Begin["`Private`"];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFGrammar*)



(* ::Text:: *)
(*
	I\[CloseCurlyQuote]m implementing this directly from https://www.ics.uci.edu/~pattis/misc/ebnf2.pdf
*)



(* ::Text:: *)
(*We\[CloseCurlyQuote]re gonna have a few special heads here (just because explicit types are useful). These will map very directly onto Mathematica structures (obviously, because Mathematica is implemented using EBNF-type rules).*)



Unprotect[
  EBNFAlternatives, EBNFSequence, EBNFRule, EBNFOptional, EBNFRepeated,
  EBNFAny, EBNFStringData, EBNFExcept
  ];
Clear[
  EBNFAlternatives, EBNFSequence, EBNFRule, EBNFOptional, EBNFRepeated,
  EBNFAny, EBNFStringData, EBNFExcept
  ];
Protect[
  EBNFAlternatives, EBNFSequence, EBNFRule, EBNFOptional, EBNFRepeated,
  EBNFAny, EBNFStringData, EBNFExcept
  ]; (* protecting against my tendency to accidentally type := instead of \[RuleDelayed] *)


EBNFRule[name_, structure_];
EBNFSequence[seq__];
EBNFAlternatives[alts__];
EBNFOptional[structure_, val_];
EBNFRepeated[structure_];


EBNFAny[];
EBNFStringData[];
EBNFExcept[pat_, tags_];


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarValue*)



BuildEBNFGrammarValue//Clear


normalizeSlots[a_]:=
  a/.Verbatim[Blank][s_Symbol]:>Blank[SymbolName[s]]


BuildEBNFGrammarValue[Verbatim[Except][a_, b_]]:=
  EBNFExcept[BuildEBNFGrammarValue[a], BuildEBNFGrammarValue[b]];
BuildEBNFGrammarValue[String|String[]|Verbatim[_String]]:=
  EBNFStringData[];
BuildEBNFGrammarValue[Verbatim[Alternatives][a__]]:=
  BuildEBNFGrammarValue/@EBNFAlternatives[a]//normalizeSlots;


BuildEBNFGrammarValue[Verbatim[Sequence][a__]]:=
  BuildEBNFGrammarValue/@EBNFSequence[a]//normalizeSlots;
BuildEBNFGrammarValue[Verbatim[PatternSequence][a__]]:=
  BuildEBNFGrammarValue[Sequence[a]];


BuildEBNFGrammarValue[Verbatim[Repeated][a_]]:=
  BuildEBNFGrammarValue/@EBNFRepeated[a]//normalizeSlots;


BuildEBNFGrammarValue[Verbatim[Optional][a_, b_]]:=
  BuildEBNFGrammarValue/@EBNFOptional[a, b]//normalizeSlots;


BuildEBNFGrammarValue[Verbatim[_]|Verbatim[__]|Verbatim[___]]:=
  EBNFAny[];


BuildEBNFGrammarValue[HoldPattern[v_]]:=BuildEBNFGrammarValue[v]
BuildEBNFGrammarValue[e_]:=e;


BuildEBNFGrammarValue~SetAttributes~{HoldAll, SequenceHold};


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarSymbol*)



BuildEBNFGrammarSymbol[s:_Symbol]:=
  {_SymbolName[s]};
BuildEBNFGrammarSymbol[s:_String]:=
  {_s};
BuildEBNFGrammarSymbol[{e_, ops___}]:=
  {BuildEBNFGrammarSymbol[e][[1]], ops};
BuildEBNFGrammarSymbol[e_]:=
  {e};


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarRule*)



BuildEBNFGrammarRule[(Rule|RuleDelayed)[r_, v_]]:=
  With[{sym=BuildEBNFGrammarSymbol[r]},
    EBNFRule[sym[[1]], BuildEBNFGrammarValue[v], Rest[sym]]
    ];
BuildEBNFGrammarRule[e_EBNFRule]:=
  e;
BuildEBNFGrammarRule~SetAttributes~{HoldAll, SequenceHold}


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammar*)



BuildEBNFGrammar[rules:{(_RuleDelayed|_Rule|_EBNFRule)..}]:=
  Module[
    {grammarStructs},
    grammarStructs = BuildEBNFGrammarRule/@rules;
    (* allows us to reuse struct names *)
    <|
      "Rules"->
        Thread[
          EBNFRule[
            grammarStructs[[All, 1]],
            grammarStructs[[All, 2]] //. 
              Map[Verbatim[Replace[#[[1]], {l_, ___}:>l]]->#[[2]]&, grammarStructs],
            grammarStructs[[All, 3]]
            ]
          ]
      |>
    ];
BuildEBNFGrammar[a_Association]:=
  If[KeyExistsQ[a, "Rules"], a, BuildEBNFGrammar[Normal@a]];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFLexer*)



(* ::Subsubsubsection::Closed:: *)
(*CollectEBNFTokens*)



(* ::Text:: *)
(*
	Determines the necessary set of tokens to feed to the tokenizer to build the grammar
*)



$convertEBNFTokenRules=
  Dispatch@
    {
      EBNFAlternatives[a___]:>
        CollectEBNFTokens@{a},
      (* there are a few special formats where we _don't_ want all apparent tokens *)
      EBNFSequence[tag_, EBNFStringData[], EBNFExcept[escape_, end_]]:>
        Flatten@With[
          {
            spec=Thread[{"String", Flatten@CollectEBNFTokens[{end}]}],
            main=CollectEBNFTokens[{tag}]
            },
          Table[
            t->spec,
            {t, main}
            ]
          ],
      EBNFSequence[tag_, EBNFStringData[]]:>
        Sequence@@CollectEBNFTokens[{EBNFSequence[tag, EBNFStringData[], tag]}],
      EBNFSequence[tag_, EBNFStringData[], end:Except[_EBNFExcept]]:>
        Sequence@@CollectEBNFTokens[{
          EBNFSequence[tag, EBNFStringData[], EBNFExcept["\\", end]]
          }],
      EBNFSequence[e___]:>
        CollectEBNFTokens@{e},
      EBNFOptional[arg_]:>
       stickyOptional[Value@CollectEBNFTokens[{arg}]],
      EBNFRepeated[arg_]:>
        repeatTokens[CollectEBNFTokens[{arg}], 10],
      EBNFRule[
        name_,
        struct_,
        ops___
        ]:>({name[[1]], ops}->Flatten[CollectEBNFTokens@{struct}, 1]),
      s_String:>s,
      _->Nothing
      };


CollectEBNFTokens[e_EBNFGrammar]:=
  CollectEBNFTokens[e["Rules"]];
CollectEBNFTokens[rules_List]:=
  Replace[rules, $convertEBNFTokenRules, 1];


(* ::Subsubsubsection::Closed:: *)
(*repeatTokens*)



repeatTokens[tok_, n_]:=
  Map[StringRepeat[tok, #]&, Range[n]];
repeatTokens~SetAttributes~Listable;


(* ::Subsubsubsection::Closed:: *)
(*stickyOptional*)



stickyOptional/:
  {a___, stickyOptional[tags_], b:_String|_List, c___}:=
    {a, glomOptional[tags, b], c};
glomOptional[tag_, tok_]:=
  tag<>tok;
glomOptional~SetAttributes~Listable;


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFLexer*)



BuildEBNFLexer[e_EBNFGrammar]:=
  LexerObject@
    Replace[
      DeleteDuplicates@Flatten@Values@CollectEBNFTokens[e],
      (a_->b_):>Flatten[{a, b}],
      1
      ];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFParser*)



(* ::Subsubsubsection::Closed:: *)
(*CollectEBNFTokenPatterns*)



(* ::Text:: *)
(*
	Need a good way to go from simple rules to the full spec
*)



$convertEBNFPatternRules=
  Dispatch@
    {
      EBNFSequence[start_, EBNFAny[], end_]:>
        {"Delimited", {start, end}},
      EBNFSequence[EBNFAny[], op_, EBNFAny[]]:>
        "Operator",
      EBNFSequence[op_, anys:EBNFAny[]..]:>
        {"FixedLength", Length@{anys}},
      EBNFSequence[op_, anys:EBNFAny[]..]:>
        {"FixedLength", Length@{anys}},
      EBNFSequence[EBNFAny[], op_]:>
        "Default",
      EBNFSequence[_, EBNFStringData[], ___]:>
        "Complete",
      EBNFSequence[struct:Except[EBNFAny[]]..]:>
        {"Structured", Replace[CollectEBNFTokens[{struct}], {a_, ___}:>a, 1]},
      EBNFRule[
        name_,
        struct_,
        ops___
        ]:>({name[[1]], ops}->Flatten[collectTokenBlockTypes@{struct}, 1]),
      s_String:>s,
      _->Nothing
      };


collectTokenBlockTypes[rules_]:=
  Replace[rules, $convertEBNFPatternRules, 1]


CollectEBNFTokenPatterns[e_EBNFGrammar]:=
  CollectEBNFTokenPatterns[e["Rules"]];
CollectEBNFTokenPatterns[rules_List]:=
  With[
    {
      tokens=Association@CollectEBNFTokens[rules],
      blocks=Association@collectTokenBlockTypes[rules]
      },
   DeleteDuplicatesBy[#Token&]@Flatten@Values@MapIndexed[
      With[{k=#2[[1, 1]], b=blocks[#2[[1, 1]]]},
        MapIndexed[
          <|
            "Token"->Replace[#, (a_->_):>a],
            If[b[[1]]=="Delimited",
              "TokenType"->If[EvenQ[#2[[1]]], "BlockCloser", "BlockOpener"],
              Nothing
              ],
            "BlockType"->
                If[Length[b]==1, b[[1]], b],
            "BlockName"->k[[1]],
            Sequence@@k[[2]]
            |>&,
          Flatten@#
          ]
        ]&,
      tokens
      ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFParser*)



(* ::Text:: *)
(*
	Builds a ParserObject that can handle the specified EBNF grammar
*)



BuildEBNFParser[e_EBNFGrammar]:=
  Module[{lexer=BuildEBNFLexer[e], p},
    p = 
      ParserObject[
        lexer,
        CollectEBNFTokenPatterns[e]
        ];
    InterfaceModify[
      ParserObject,
      p,
      Append[#, "Grammar"->e]&
      ]
    ]


End[];



