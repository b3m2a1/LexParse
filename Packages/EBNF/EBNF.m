(* ::Package:: *)

(* Autogenerated Package *)

EBNFRule::usage="";
EBNFSequence::usage="";
EBNFAlternatives::usage="";
EBNFOptional::usage="";
EBNFRepeated::usage="";


BuildEBNFGrammar::usage="";


BuildEBNFGrammarRule::usage="";
BuildEBNFGrammarSymbol::usage="";
BuildEBNFGrammarValue::usage="";


BuildEBNFLexer::usage="";
CollectEBNFTokens::usage="";


BuildEBNFParser::usage="";
CollectEBNFTokenPatterns::usage="";


Begin["`Private`"];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFGrammar*)



(* ::Text:: *)
(*
	I\[CloseCurlyQuote]m implementing this directly from https://www.ics.uci.edu/~pattis/misc/ebnf2.pdf
*)



(* ::Text:: *)
(*We\[CloseCurlyQuote]re gonna have a few special heads here (just because explicit types are useful). These will map very directly onto Mathematica structures (obviously, because Mathematica is implemented using EBNF-type rules).*)



EBNFRule[name_, structure_];
EBNFSequence[seq__];
EBNFAlternatives[alts__];
EBNFOptional[structure_, val_];
EBNFRepeated[structure_];


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarValue*)



normalizeSlots[a_]:=
  a/.Verbatim[Blank][s_Symbol]:>Blank[SymbolName[s]]


BuildEBNFGrammarValue[Verbatim[Alternatives][a__]]:=
  normalizeSlots@EBNFAlternatives[a];
BuildEBNFGrammarValue[Verbatim[Sequence][a__]]:=
  normalizeSlots@EBNFSequence[a];
BuildEBNFGrammarValue[Verbatim[Repeated][a_]]:=
  normalizeSlots@EBNFRepeated[a];
BuildEBNFGrammarValue[Verbatim[Optional][a_, b_]]:=
  normalizeSlots@EBNFOptional[a, b];
BuildEBNFGrammarValue~SetAttributes~{HoldAll, SequenceHold};


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarSymbol*)



BuildEBNFGrammarSymbol[s:_Symbol]:=
  {_SymbolName[s]};
BuildEBNFGrammarSymbol[s:_String]:=
  {_s};
BuildEBNFGrammarSymbol[{e_, ops___}]:=
  {BuildEBNFGrammarSymbol[e], ops};
BuildEBNFGrammarSymbol[e_]:=
  {e};


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarRule*)



BuildEBNFGrammarRule[(Rule|RuleDelayed)[r_, v_]]:=
  With[{sym=BuildEBNFGrammarSymbol[r]},
    EBNFRule[sym[[1]], BuildEBNFGrammarValue[v], Sequence@@Rest[sym]]
    ];
BuildEBNFGrammarRule[e_EBNFRule]:=
  e;
BuildEBNFGrammarRule~SetAttributes~{HoldAll, SequenceHold}


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammar*)



BuildEBNFGrammar[rules:{(_RuleDelayed|_Rule|_EBNFRule)..}]:=
  Module[
    {grammarStructs},
    grammarStructs = BuildEBNFGrammarRule/@rules;
    (* allows us to reuse struct names *)
    <|
      "Rules"->
        Thread[
          EBNFRule[
            grammarStructs[[All, 1]],
            grammarStructs[[All, 2]] //. 
              Map[Verbatim[Replace[#[[1]], {l_, ___}:>l]]->#[[2]]&, grammarStructs]
            ]
          ]
      |>
    ];
BuildEBNFGrammar[a_Association]:=
  If[KeyExistsQ[a, "Rules"], a, BuildEBNFGrammar[Normal@a]];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFLexer*)



(* ::Subsubsubsection::Closed:: *)
(*CollectEBNFTokens*)



(* ::Text:: *)
(*
	Determines the necessary set of tokens to feed to the tokenizer to build the grammar
*)



CollectEBNFTokens[e_EBNFGrammar]:=
  CollectEBNFTokens[e["Rules"]];
CollectEBNFTokens[rules_List]:=
  Replace[
    rules,
    {
      EBNFRule[
        _,
        EBNFSequence[d1_, Verbatim[___]|Verbatim[__], d2_],
        ops___
        ]:>Sequence@@Map[{#, ops}&, {d1, d2}],
      EBNFRule[_, 
        EBNFSequence[head_String, ___], ops___]:>{head, ops},
      EBNFRule[_, 
        EBNFSequence[args__], ops___]:>{FirstCase[{args}, _String], ops},
      EBNFRule[_, e_, ops___]:>{e, ops},
      s_String:>{s},
      _->Nothing
      },
    1
    ];


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFLexer*)



BuildEBNFLexer[e_EBNFGrammar]:=
  LexerObject[Flatten@CollectEBNFTokens[e]];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFParser*)



(* ::Subsubsubsection::Closed:: *)
(*CollectEBNFTokenPatterns*)



(* ::Text:: *)
(*
	Need a good way to go from simple rules to the full spec
*)



collectTokenBlockTypes[rules_]:=
  Replace[
    rules,
    {
      EBNFSequence[start_, Verbatim[___], end_]:>
        {"Delimited", {start, end}},
     EBNFSequence[_, op_String, _]:>
        "Operator",
     EBNFSequence[head_String, body__]:>
        {"Structured", collectEBNFTokens[{head, body}]},
      _->Nothing
      },
    1
    ]


CollectEBNFTokenPatterns[e_EBNFGrammar]:=
  CollectEBNFTokenPatterns[e["Rules"]];
CollectEBNFTokenPatterns[rules_List]:=
  MapThread[
    <|
      "Token"->If[ListQ@#, First[#], #],
      "BlockType"->#2,
      Sequence@@If[ListQ@#, Rest[#], {}]
      |>&,
    {
      CollectEBNFTokens,
      collectTokenBlockTypes[rules[[All, 2]]]
      }
    ];


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFParser*)



(* ::Text:: *)
(*
	Builds a ParserObject that can handle the specified EBNF grammar
*)



BuildEBNFParser[e_EBNFGrammar]:=
  Module[{lexer=BuildEBNFLexer[e], p},
    p = ParserObject[
      lexer,
      CollectEBNFTokenPatterns[e]
      ];
    InterfaceModify[ParserObject,
      p,
      Append[#, "Grammar"->e]&
      ]
    ]


End[];



