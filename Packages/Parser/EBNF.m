(* ::Package:: *)

(* Autogenerated Package *)

EBNFGrammar::usage=
  "An object defining an EBNFGrammar that we can use to build our Parser";


Begin["`Private`"];


(* ::Subsection:: *)
(*EBNFGrammar*)



RegisterInterface[
  EBNFGrammar,
  {
    "Rules"
    },
  "Constructor"->BuildEBNFGrammar
  ]


(* ::Subsubsection::Closed:: *)
(*BuildEBNFGrammar*)



(* ::Text:: *)
(*
	I\[CloseCurlyQuote]m implementing this directly from https://www.ics.uci.edu/~pattis/misc/ebnf2.pdf
*)



(* ::Text:: *)
(*We\[CloseCurlyQuote]re gonna have a few special heads here (just because explicit types are useful). These will map very directly onto Mathematica structures (obviously, because Mathematica is implemented using EBNF-type rules).*)



EBNFRule[name_, structure_];
ENBFSequence[seq__];
EBNFAlternatives[alts__];
EBNFOptional[structure_, val_];
EBNFRepeated[structure_];


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarValue*)



BuildEBNFGrammarValue[Verbatim[Alternatives][a__]]:=
  EBNFAlternatives[a];
BuildEBNFGrammarValue[Verbatim[Sequence][a__]]:=
  ENBFSequence[a];
BuildEBNFGrammarValue[Verbatim[Repeated][a_]]:=
  EBNFRepeated[a];
BuildEBNFGrammarValue[Verbatim[Optional][a_, b_]]:=
  EBNFOptional[a, b];
BuildEBNFGrammarValue~SetAttributes~{HoldAll, SequenceHold};


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarSymbol*)



BuildEBNFGrammarSymbol[s:_Symbol]:=
  _SymbolName[s];
BuildEBNFGrammarSymbol[s:_String]:=
  _s;
BuildEBNFGrammarSymbol[e_]:=
  e;


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammarRule*)



BuildEBNFGrammarRule[(Rule|RuleDelayed)[r_, v_]]:=
  EBNFRule[BuildEBNFGrammarSymbol[r], BuildEBNFGrammarValue[v]];
BuildEBNFGrammarRule[e_EBNFRule]:=
  e;
BuildEBNFGrammarRule~SetAttributes~{HoldAll, SequenceHold}


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFGrammar*)



BuildEBNFGrammar[rules:{(_RuleDelayed|_Rule|_EBNFRule)..}]:=
  Module[
    {grammarStructs},
    grammarStructs = BuildEBNFGrammarValue/@rules;
    (* allows us to reuse struct names *)
    <|
      "Rules"->
        Thread[
          EBNFRule@
            {
              grammarStructs[[All, 1]],
              grammarStructs[[All, 2]] //. 
                Map[Verbatim[#[[1]]]->#[[2]]&, grammarStructs]
              }
          ]
      |>
    ];
BuildEBNFGrammar[a_Association]:=
  If[KeyExistsQ[a, "Rules"], a, BuildEBNFGrammar[Normal@a]];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFLexer*)



(* ::Subsubsubsection::Closed:: *)
(*CollectEBNFTokens*)



(* ::Text:: *)
(*
	Determines the necessary set of tokens to feed to the tokenizer to build the grammar
*)



CollectEBNFTokens[e_EBNFGrammar]:=
  CollectEBNFTokens[e["Rules"]];
CollectEBNFTokens[rules_List]:=
  None;


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFLexer*)



BuildEBNFLexer[e_EBNFGrammar]:=
  LexerObject[CollectEBNFTokens[e]];


(* ::Subsubsection::Closed:: *)
(*BuildEBNFParser*)



(* ::Subsubsubsection::Closed:: *)
(*CollectEBNFTokenPatterns*)



CollectEBNFTokenPatterns[e_EBNFGrammar]:=
  CollectEBNFTokenPatterns[e["Rules"]];
CollectEBNFTokenPatterns[rules_List]:=
  None;


(* ::Subsubsubsection::Closed:: *)
(*BuildEBNFParser*)



(* ::Text:: *)
(*
	Builds a ParserObject that can handle the specified EBNF grammar
*)



BuildEBNFParser[e_EBNFGrammar]:=
  Module[{lexer=BuildEBNFLexer[e]},
    ParserObject[
      lexer,
      CollectEBNFTokenPatterns[e]
      ]
    ]


End[];



