(* ::Package:: *)

(* Autogenerated Package *)

ConstructParserObject::usage="";
ParseStream::usage="";
ApplyParser::usage="";


Begin["`Private`"];


(* ::Subsubsection::Closed:: *)
(*ConstructParserObject*)



(* ::Subsubsubsection::Closed:: *)
(*normalizeTokenHandler*)



normalizeTokenHandler//Clear


(* ::Subsubsubsubsection::Closed:: *)
(*BlockDelimiter*)



normalizeTokenHandler[{a_String, a_String, ops___?OptionQ}]:=
  Join[
    normalizeTokenHandler[a],
    <|
      "TokenType"->"BlockDelimiter",
      "BlockType"->{"Delimited", {a, a}},
      ops
      |>
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Delimited*)



normalizeTokenHandler[{a_String, b_String, ops___?OptionQ}]:=
  {
    Join[
      normalizeTokenHandler[a],
      <|
        "TokenType"->"BlockOpener",
        "BlockType"->{"Delimited", {a, b}},
        ops
        |>
      ],
    Join[
      normalizeTokenHandler[b],
      <|
        "TokenType"->"BlockCloser",
        ops
        |>
      ]
    };


(* ::Subsubsubsubsection::Closed:: *)
(*FixedLength*)



normalizeTokenHandler[{a_String, n_Integer, ops___?OptionQ}]:=
  Join[
    normalizeTokenHandler[a],
    <|
      "TokenType"->"BlockOpener",
      "BlockType"->{"FixedLength", n},
      ops
      |>
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Structured*)



normalizeTokenHandler[{a_String, b__String, ops___?OptionQ}]:=
  Join[
      normalizeTokenHandler[a],
      <|
        "TokenType"->"BlockOpener",
        "BlockType"->{"Structured", {a, b}},
        ops
        |>
      ];


(* ::Subsubsubsubsection::Closed:: *)
(*String*)



normalizeTokenHandler[{start_String, Verbatim[___], end_String, ops___?OptionQ}]:=
  Join[
      normalizeTokenHandler[start],
      <|
        "Token"->{start, "String", end},
        "TokenType"->"Atomic",
        "BlockType"->"Complete",
        ops
        |>
      ];


(* ::Subsubsubsubsection::Closed:: *)
(*Operator*)



normalizeTokenHandler[{Verbatim[_], op_String, Verbatim[_], ops___?OptionQ}]:=
  Join[
      normalizeTokenHandler[op],
      <|
        "TokenType"->"Operator",
        "BlockType"->"Operator",
        "Precedence"->0,
        ops
        |>
      ]


(* ::Subsubsubsubsection::Closed:: *)
(*Fallbacks*)



normalizeTokenHandler[a_String]:=
  <|
    "Token"->a,
    "TokenType"->"Atomic",
    "BlockType"->"Default",
    "DataFunction"->(#["Body"]&)
    |>


getDataFunction[a_]:=
  (#["Body"]&);
getTokenType[a_]:=
  blockTypeToTokenType[
    a["Token"],
    Lookup[a, "BlockType", "Default"]
    ];
getBlockType[a_]:=
  "Default"


blockTypeToTokenType[_, {"FixedLength", ___}]:=
  "BlockOpener";
blockTypeToTokenType[_, {"Structured", ___}]:=
  "BlockOpener";
blockTypeToTokenType[t_, {"Delimited", t_, _}]:=
  "BlockOpener";
blockTypeToTokenType[t_, {"Delimited", _, t_}]:=
  "BlockCloser";
blockTypeToTokenType[_, "Default"]:=
  "Default";
blockTypeToTokenType[_, "Operator"]:=
  "Operator";
blockTypeToTokenType[_, "Complete"]:=
  "Default";


normalizeTokenHandler[a_Association]:=
  Join[
    <|
      "DataFunction"->getDataFunction[a],
      "TokenType"->getTokenType[a],
      "BlockType"->getBlockType[a]
      |>,
    a
    ];


normalizeTokenHandler[e_]:=
  PackageRaiseException[Automatic,
    "Couldn't normalize token handler ``",
    e
    ]


(* ::Subsubsubsection::Closed:: *)
(*normalizeTokenHandlers*)



normalizeTokenHandlers[list_List]:=
  Module[{normal=Flatten[normalizeTokenHandler/@list]},
    AssociationThread[
      Lookup[normal, "Token"],
      normal
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*ConstructParserObject*)



ConstructParserObject[lexer_, tokenHandlers_]:=
  <|
    "Lexer"->lexer,
    "Handlers"->normalizeTokenHandlers@tokenHandlers
    |>


ConstructParserObject[tokenHandlers_List]:=
  Module[{toks=normalizeTokenHandlers@tokenHandlers},
    <|
      "Lexer"->LexerObject[Keys[toks]],
      "Handlers"->toks
      |>
    ]


ConstructParserObject[a_Association]:=
  a;


(* ::Subsubsection::Closed:: *)
(*handleToken*)



(* ::Subsubsubsection::Closed:: *)
(*idea*)



(* ::Text:: *)
(*
If we\[CloseCurlyQuote]ve hit a block opener like {
then we want to create a new node that\[CloseCurlyQuote]ll be inserted into the previous one after the block has been built

If we\[CloseCurlyQuote]ve hit a block closer like }
then we want to close out the current node and push it into its parent

If we\[CloseCurlyQuote]ve hit an atomic thing like \[OpenCurlyDoubleQuote]....\[CloseCurlyDoubleQuote] then we want to create and push the node

If we\[CloseCurlyQuote]ve hit a fixed-length node like . (e.g. obj.attr or obj.child.attr)  then we want to keep track of how much we need to look ahead but close off the block after the next complete node

-- Note: I opted to stick this into a BlockType attribute in the parser spec --

There might also be more complex look-ahead type parse nodes though... like we might have want to have . work until a certain token type is hit but keep the body for that one and ditch the rest...?

Or if we see a for (test) { body } we\[CloseCurlyQuote]d really like this to be specifiable as a conditional parse. Like the (test) *must* occur next and then after that we *must* have a {body} node and it should all be captured by the for node...

I guess these can be in the BlockType but as a structured block type? 

There should also be a way for the parser to handle infix type nodes? 
Like a.b.c.e + g.f.g.h should be Plus[Dot[a, b, c, e], Dot[g, f, g, h] but the natural structure from the stream would be Dot[a, b, c, Plus[e, Dot[g, f, g, h]]]. This actually is an issue of Precedence more generally... Can this be resolved in linear time?

*)



(* ::Subsubsubsection::Closed:: *)
(*handleToken*)



(* ::Text:: *)
(*
	Handles basic tokens
*)



handleToken//Clear
handleToken[spec_, next_, state_]:=
  Replace[spec["TokenType"],
    {
      "BlockOpener":>
        openNode[spec, next, state],
      "BlockCloser":>
        closeNode[spec, next, state],
      "BlockDelimiter":>
        openOrCloseNode[spec, next, state],
      "Atomic":>
        closeNode[spec, next, state],
      "Default":>
        closeNode[spec, next, state["CurrentNode"], spec["BlockType"]]
      }
    ]


(* ::Subsubsubsection::Closed:: *)
(*openOrCloseNode*)



(* ::Text:: *)
(*
	Opens or closes a node based on the current block type and what was found
*)



openOrCloseNode[spec_, next_, state_]:=
  Module[{bt=state["BlockType"], tok=next["Token"]},
    If[MatchQ[bt, {"Delimited", {_, tok}}],
      closeNode[spec, next, state],
      openNode[spec, next state]
      ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*openNode*)



(* ::Text:: *)
(*
	Opens up a new node to fill
*)



openNode[spec_, next_, state_, prepNode:True|False:True]:=
  Switch[spec["BlockType"],
    "Operator",
      <|
        "Node"->
          If[prepNode,
            MakeASTNode[
              If[spec["TokenType"]===Automatic, Automatic, "Compound"], 
              spec["DataFunction"]@next,
              next["Token"],
              spec
              ],
            next
            ],
        "Precedence"->Lookup[spec, "Precedence", -Infinity],
        "BlockType"->
          spec["BlockType"],
        "ResponseType"->
          "OpenNode"
        |>,
    _,
     Module[{pushed},
       pushed = 
         AddASTNodeData[
           state["CurrentNode"],
           MakeASTNode["Atomic", spec["DataFunction"]@next]
           ];
       <|
         "Responses"->{
           <|
             "Node"->pushed,
             "ResponseType"->"EditNode"
             |>,
           <|
            "Node"->
              If[prepNode,
                MakeASTNode[
                  "Compound", 
                  {},
                  next["Token"],
                  spec
                  ],
                next
                ],
            "Precedence"->Lookup[spec, "Precedence", -Infinity],
            "BlockType"->
              spec["BlockType"],
            "ResponseType"->
              "OpenNode"
            |>
           },
         "ResponseType"->{"EditNode", "OpenNode"}
         |>
       ]
    ];


(* ::Subsubsubsection::Closed:: *)
(*structuredNodeMatchQ*)



structuredNodeMatchQ[node_, blocks_]:=
  Block[
    {
      main = GetASTNodeProperty[node, "Token"], 
      n = DeleteCases[#["Token"]&/@GetASTNodeProperty[node, "Children"], None]
      },
    PrependTo[n, main];
    MapThread[
      If[#=!=#2,
        PackageRaiseException[Automatic,
          "Expected token '``' got '``'", 
          #2,
          #
          ]
        ]&,
      {
        n[[;;Min@{Length@n, Length@blocks}]],
        blocks[[;;Min@{Length@n, Length@blocks}]]
        }
      ];
    Length@blocks==Length@n
    ]


(* ::Subsubsubsection::Closed:: *)
(*checkClose*)



checkClose[node_, addMe_, bt:{"Delimited", {start_, end_}}]:=
  (
    If[GetASTNodeProperty[node, "Token"]=!=start, 
      PackageRaiseException[Automatic,
        "Expected opening token `` got `` in delimited pair ('``', '``')",
        start, GetASTNodeProperty[node, "Token"],
        start, end
        ]
      ];
    GetASTNodeProperty[addMe, "Token"]===end
    )
checkClose[node_, bt:{"Delimited", {start_, end_}}]:=
  checkClose[node, GetASTNodeProperty[node, "Children"][[-1]], bt];
checkClose[node_, bt:{"Structured", blocks:{__}}]:=
  structuredNodeMatchQ[node, blocks];
checkClose[___]:=False


(* ::Subsubsubsection::Closed:: *)
(*closeNode*)



(* ::Text:: *)
(*
	This is really where all the AST patterns are defined...
*)



closeNode//Clear


(* ::Subsubsubsubsection::Closed:: *)
(*Delimited*)



closeNode[spec_, next_, node_, bt:{"Delimited", {start_, end_}}]:=
  Module[{n},
    n=
      AddASTNodeData[node, 
        MakeASTNode["Atomic", spec["DataFunction"]@next, next["Token"], spec]
        ];
    <|
      "Node"->n,
      "BlockType"->bt,
      "Precedence"->Lookup[spec, "Precedence", -Infinity],
      "ResponseType"->
        If[!checkClose[n, bt],
          "EditNode",
          "CloseNode"
          ]
      |>
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*Structured*)



(* ::Text:: *)
(*
	For things like for (a...) {b...}
*)



closeNode[spec_, next_, node_, bt:{"Structured", blocks:{__}}]:=
  Module[{main},
    main=
      AddASTNodeData[node, 
        MakeASTNode["Atomic", spec["DataFunction"]@next, next["Token"], spec]
        ];
    <|
      "Node"->main,
      "BlockType"->bt,
      "Precedence"->Lookup[spec, "Precedence", -Infinity],
      "ResponseType"->
        If[!checkClose[node, bt],
          "EditNode",
          "CloseNode"
          ]
      |>
    ];


(* ::Subsubsubsubsection::Closed:: *)
(*FixedLength*)



(* ::Text:: *)
(*
	For things like eval f g h
*)



closeNode[spec_, next_, node_, bt:{"FixedLength", n_}]:=
  <|
    "Node"->
      AddASTNodeData[node, 
        MakeASTNode["Atomic", spec["DataFunction"]@next, next["Token"], spec]
        ],
    "BlockType"->bt,
    "Precedence"->Lookup[spec, "Precedence", -Infinity],
    "ResponseType"->
      If[GetASTNodeProperty[node, "ChildCount"]<n-1,
        "EditNode",
        "CloseNode"
        ]
    |>;


(* ::Subsubsubsubsection::Closed:: *)
(*Complete*)



(* ::Text:: *)
(*
	For things like strings where the Body is really a complete node
*)



closeNode[spec_, next_, node_, bt:"Complete"]:=
  <|
    "Node"->
      With[{d=spec["DataFunction"]@next},
        AddASTNodeData[node, 
          {
            MakeASTNode["Atomic", d[[1]], None, <||>],
            MakeASTNode["Atomic", d[[2]], next["Token"], spec]
            }
          ]
        ],
    "Precedence"->Lookup[spec, "Precedence", -Infinity],
    "BlockType"->node["BlockType"],
    "ResponseType"->"EditNode"
    |>


(* ::Subsubsubsubsection::Closed:: *)
(*Default*)



(* ::Text:: *)
(*
	For things like ...;
*)



closeNode[spec_, next_, node_, bt:"Default"]:=
  <|
    "Node"->
      With[{d=spec["DataFunction"]@next},
        AddASTNodeData[node, 
          If[ListQ@d,
            MakeASTNode["Atomic", #, next["Token"], spec]&/@d,
            MakeASTNode["Atomic", d, next["Token"], spec]
            ]
          ]
        ],
    "Precedence"->Lookup[spec, "Precedence", -Infinity],
    "BlockType"->node["BlockType"],
    "ResponseType"->"EditNode"
    |>;


(* ::Subsubsubsubsection::Closed:: *)
(*Current*)



(* ::Text:: *)
(*
	Not sure why I implemented this?
*)



closeNode[spec_, next_, node_, bt:"Current"]:=
  <|
    "Node"->node,
    "Precedence"->Lookup[spec, "Precedence", -Infinity],
    "BlockType"->node["BlockType"],
    "ResponseType"->"CloseNode"
    |>


(* ::Subsubsubsubsection::Closed:: *)
(*Operator*)



(* ::Text:: *)
(*
	For things like a.b or b+c
*)



closeNode[spec_, next_, node_, bt:"Operator"]:=
  <|
    "Node"->
      AddASTNodeData[node, 
        MakeASTNode["Atomic", spec["DataFunction"]@next, None, <||>]
        ],
    "Precedence"->Lookup[spec, "Precedence", 0],
    "BlockType"->node["BlockType"],
    "ResponseType"->"EditNode"
    |>


(* ::Subsubsubsubsection::Closed:: *)
(*Fallbacks*)



closeNode[spec_, next_, node_, e_]:=
  PackageRaiseException[Automatic, "Invalid block type: ``", e];
closeNode[spec_, next_, state_]:=
  closeNode[spec, next, state["CurrentNode"], state["BlockType"]];


(* ::Subsubsubsection::Closed:: *)
(*closeOpenNode*)



(* ::Text:: *)
(*
	Closes a node and opens a new one with the current one as data.
	Basically a way to close a node, open a node, then set that node as a parent node of the prior one.
	Requires less tree manipulation, though.
*)



closeOpenNode[spec_, next_, state_]:=
  Module[{closed=closeNode[spec, next, state]},
    <|
      "Node"->
        MakeASTNode[
          "Compound", 
          {closed["Node"]},
          next["Token"],
          spec
          ],
      "Precedence"->spec["Precedence"],
      "BlockType"->spec["BlockType"],
      "ResponseType"->"EditNode"
      |>
    ]


(* ::Subsubsubsection::Closed:: *)
(*handleOperator*)



(* ::Text:: *)
(*
	Handles precedence relations for operators
*)



handleOperator[spec_, next_, state_]:=
  Which[
    state["Precedence"]<spec["Precedence"],
      (* the next node has a higher precedence than the current node so we simply open a new node *)
      openNode[spec, next, state],
    state["Precedence"]==spec["Precedence"],
      (* 
                the next node has a equal precedence to the current node so we close off the current one 
                  and open a new one with the current one as an argument
             *)
      closeOpenNode[spec, next, state],
    True,
      (* 
                the next node has a lower precedence than the current node... but operationally it's like equal for now
               *)
      closeOpenNode[spec, next, state]
    ]


(* ::Subsubsection::Closed:: *)
(*ApplyParser*)



(* ::Subsubsubsection::Closed:: *)
(*idea*)



(* ::Text:: *)
(*
	We\[CloseCurlyQuote]re gonna have a two layer parser, with a standard recursive descent parser which dumps into an operator-precedence parser when necessary and then that calls back into the recursive descent parser
	An example of how this could work:
	
	for ( int i = 0; i<10; i++ ) { ...
	
	1: Tokenizer returns {\[OpenCurlyDoubleQuote]\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote]for\[CloseCurlyDoubleQuote]}
		recursive-descent parser sees for: opens Node0({\[OpenCurlyDoubleQuote]\[CloseCurlyDoubleQuote]}, \[OpenCurlyDoubleQuote]for\[CloseCurlyDoubleQuote]);
	2: Tokenizer returns {\[OpenCurlyDoubleQuote] \[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote](\[CloseCurlyDoubleQuote]}
		RDP sees \[OpenCurlyDoubleQuote](\[OpenCurlyDoubleQuote]: pushes Node0 onto RDP stack; opens Node1({\[OpenCurlyDoubleQuote] \[OpenCurlyDoubleQuote]}, \[OpenCurlyDoubleQuote](\[OpenCurlyDoubleQuote]);
	3: Tokenizer returns {\[OpenCurlyDoubleQuote]int i\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote]=\[CloseCurlyDoubleQuote]}
		RDP sees \[OpenCurlyDoubleQuote]=\[CloseCurlyDoubleQuote], an infix operator: enters operator-precedence parser
		OPP opens Node2({\[OpenCurlyDoubleQuote]int i\[CloseCurlyDoubleQuote]}, \[OpenCurlyDoubleQuote]=\[CloseCurlyDoubleQuote])
		4: Tokenizer returns {\[OpenCurlyDoubleQuote]0\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote];\[CloseCurlyDoubleQuote]}
			OPP sees \[OpenCurlyDoubleQuote];\[CloseCurlyDoubleQuote] which is infix with lower precedence:
			 	inserts \[OpenCurlyDoubleQuote]0\[CloseCurlyDoubleQuote] into Node2; closes Node2 and opens Node3({Node2}, \[OpenCurlyDoubleQuote];\[CloseCurlyDoubleQuote]);
		5: Tokenizer returns {\[OpenCurlyDoubleQuote] i\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote]<\[CloseCurlyDoubleQuote]}
		 	OPP sees \[OpenCurlyDoubleQuote]<\[CloseCurlyDoubleQuote] which is infix with higher precedence:
		 		pushes Node3 onto OPP stack; opens Node4({\[OpenCurlyDoubleQuote] i\[CloseCurlyDoubleQuote]}, \[OpenCurlyDoubleQuote]<\[CloseCurlyDoubleQuote])
		 6: Tokenizer returns {\[OpenCurlyDoubleQuote]10\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote];\[CloseCurlyDoubleQuote]}
		 	OPP sees \[OpenCurlyDoubleQuote];\[CloseCurlyDoubleQuote] which is infix with lower precedence:
				inserts \[OpenCurlyDoubleQuote]10\[CloseCurlyDoubleQuote] into Node4; closes Node4 and inserts Node4 into Node3;
				\[OpenCurlyDoubleQuote];\[CloseCurlyDoubleQuote] has same precedence as Node3; closes Node3 and opens Node5({Node3}, \[OpenCurlyDoubleQuote];\[CloseCurlyDoubleQuote])
		7: Tokenizer returns {\[OpenCurlyDoubleQuote] i\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote]++\[CloseCurlyDoubleQuote]}
			OPP sees \[OpenCurlyDoubleQuote]++\[CloseCurlyDoubleQuote] which is not an infix operator and higher precedence than \[OpenCurlyDoubleQuote];\[CloseCurlyDoubleQuote]
				inserts Node6({\[OpenCurlyDoubleQuote] i\[CloseCurlyDoubleQuote]}, \[OpenCurlyDoubleQuote]++\[CloseCurlyDoubleQuote]) into Node5
		8: Tokenizer returns {\[OpenCurlyDoubleQuote] \[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote])\[CloseCurlyDoubleQuote]}
			OPP sees \[OpenCurlyDoubleQuote])\[CloseCurlyDoubleQuote] which is not and infix operator and lower equal precedence to \[OpenCurlyDoubleQuote];\[CloseCurlyDoubleQuote]
				closes Node6 and inserts into Node1
				exits OPP
		RDP sees \[OpenCurlyDoubleQuote])\[CloseCurlyDoubleQuote]: matches closer for Node1 and so closes Node1
	9: Tokenizer returns \[OpenCurlyDoubleQuote]{\[OpenCurlyDoubleQuote] ...

Another example would be
	
	i+2*5^(x+10)
	
	1: Tokenizer returns {\[OpenCurlyDoubleQuote]i\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote]+\[CloseCurlyDoubleQuote]}
		RDP sees \[OpenCurlyDoubleQuote]+\[CloseCurlyDoubleQuote]: enters ODP
		OPD sees \[OpenCurlyDoubleQuote]+\[CloseCurlyDoubleQuote]: opens Node0({\[OpenCurlyDoubleQuote]i\[CloseCurlyDoubleQuote]}, \[OpenCurlyDoubleQuote]+\[CloseCurlyDoubleQuote])
		2: Tokenizer returns {\[OpenCurlyDoubleQuote]2\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote]*\[CloseCurlyDoubleQuote]}
			ODP sees \[OpenCurlyDoubleQuote]*\[CloseCurlyDoubleQuote] which is a higher precedence operator than \[OpenCurlyDoubleQuote]+\[CloseCurlyDoubleQuote]:
				opens Node1({\[OpenCurlyDoubleQuote]2\[CloseCurlyDoubleQuote]}, \[OpenCurlyDoubleQuote]*\[CloseCurlyDoubleQuote])
		3: Tokenizer returns {\[OpenCurlyDoubleQuote]5\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote]^\[CloseCurlyDoubleQuote]}
			ODP sees \[OpenCurlyDoubleQuote]^\[CloseCurlyDoubleQuote] which is a higher precedence operator than \[OpenCurlyDoubleQuote]+\[OpenCurlyDoubleQuote]:
				opens Node2({\[OpenCurlyDoubleQuote]5\[CloseCurlyDoubleQuote]}, \[OpenCurlyDoubleQuote]*\[CloseCurlyDoubleQuote])
		4: Tokenizer returns {\[OpenCurlyDoubleQuote]\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote](\[CloseCurlyDoubleQuote]}:
			ODP sees this neither an infix operator nor a right-associative operator: enters RDP
			RDP sees \[OpenCurlyDoubleQuote](\[OpenCurlyDoubleQuote]: opens Node3({\[OpenCurlyDoubleQuote]\[CloseCurlyDoubleQuote]}, \[OpenCurlyDoubleQuote](\[CloseCurlyDoubleQuote])
			5: Tokenizer returns  {\[OpenCurlyDoubleQuote]x\[CloseCurlyDoubleQuote], \[OpenCurlyDoubleQuote]+\[OpenCurlyDoubleQuote]}:
				RDP sees \[OpenCurlyDoubleQuote]+\[OpenCurlyDoubleQuote]: enters ODP
				OPD sees \[OpenCurlyDoubleQuote]+\[OpenCurlyDoubleQuote]: opens Node4({\[OpenCurlyDoubleQuote]x\[CloseCurlyDoubleQuote]}, \[OpenCurlyDoubleQuote]+\[OpenCurlyDoubleQuote])
			...	
*)



(* ::Subsubsubsection::Closed:: *)
(*exprStack*)



(* ::Text:: *)
(*
	Simple mutable stack type
*)



exprStack[]:=
  With[{s=Unique[stackVar]}, 
    SetAttributes[s, Temporary];
    s = {};
    exprStack[s]
    ];
exprStack[s_]@"Push"[val_]:=
  (AppendTo[s, val];s[[-1]]);
exprStack[s_]@"Pop"[]:=
  With[{old=s[[-1]]}, s=s[[;;-2]]; old];
exprStack[s_]@"Size"[]:=
  Length[s];
exprStack~SetAttributes~HoldFirst;


(* ::Subsubsubsection::Closed:: *)
(*continueParse*)



continueParse[handler_, next_]:=
  (!MissingQ[handler])&&(next["Body"]=!=EndOfFile)


(* ::Subsubsubsection::Closed:: *)
(*manageResponse*)



manageResponse[{stack_, state_}, resp_, toks_]:=
  imanageResponse[{stack, state}, resp["ResponseType"], resp, toks];
manageResponse~SetAttributes~HoldFirst;


imanageResponse[{stack_, state_}, type_, resp_, toks_]:=
  Switch[type,
    "OpenNode",
      AppendTo[stack, state];
      state["CurrentNode"] = resp["Node"];
      state["BlockType"] = resp["BlockType"];
      state["Precedence"] = resp["Precedence"];,
    "EditNode",
      state["CurrentNode"] = resp["Node"],
    "CloseNode",
      state = stack[[-1]];
      stack = stack[[;;-2]];
      state["CurrentNode"] = AddASTNodeData[state["CurrentNode"], resp["Node"]];
      (* need to cascade our close, potentially *)
      manageCascadingClose[{state, stack}],
    "ReturnNode", 
      (* much like closing a node, but rather than inserting it into its parent we simply set the node state *)
      state = stack[[-1]];
      stack = stack[[;;-2]];
      state["CurrentNode"] = resp["Node"],
    _List,
      MapThread[
        imanageResponse[{stack, state}, #, #2, toks]&,
        {
          type,
          resp["Responses"]
          }
        ]
    ];
imanageResponse~SetAttributes~HoldFirst;


(* ::Subsubsubsection::Closed:: *)
(*manageCascadingClose*)



manageCascadingClose[{state_, stack_}]:=
  With[{node=state["CurrentNode"]},
    If[checkClose[node, state["BlockType"]],
      imanageResponse[{stack, state}, "CloseNode", <|"Node"->node|>, None]
      ]
    ];
manageCascadingClose~SetAttributes~HoldFirst;


(* ::Subsubsubsection::Closed:: *)
(*useODP*)



useODP[handler_, next_]:=
  TrueQ[handler["TokenType"]=="Operator"];


(* ::Subsubsubsection::Closed:: *)
(*handleExitODP*)



handleExitODP[{stack_, state_}, handler_, next_]:=
  Switch[handler["TokenType"],
    "BlockOpener",
      None,
    "BlockCloser",
      closeNode[handler, next, state],
    _,
      With[
        {r1=closeOpenNode[handler, next, state]},
        <|
          "Responses"->{r1, closeNode[handler, next, r1["Node"], "Current"]},
          "ResponseType"->{
            r1["ResponseType"],
            "CloseNode"
            }
          |>
        ]
    ]


(* ::Subsubsubsection::Closed:: *)
(*parseStream*)



parseStream[{stack_, state_, handlers_}, toks_]:=
  Module[
    {
      next, handler, resp,
      mode = "RDP"
      },
    next = toks@"Read"[];
    handler = Lookup[handlers, next["Token"]];
    While[continueParse[handler, next],
      If[mode==="RDP",
        If[!useODP[handler, next],
          resp = handleToken[handler, next, state];
          manageResponse[{stack, state}, resp, toks];
          next = toks@"Read"[];
          handler = Lookup[handlers, next["Token"]];,
          mode = "ODP"
          ],
        If[useODP[handler, next],
          resp = handleOperator[handler, next, state];
          manageResponse[{stack, state}, resp, toks];
          next = toks@"Read"[];
          handler = Lookup[handlers, next["Token"]];,
          resp = handleExitODP[{stack, state}, handler, next];
          If[resp=!=None, 
            manageResponse[{stack, state}, resp, toks];
            next = toks@"Read"[];
            handler = Lookup[handlers, next["Token"]];
            ];
          mode = "RDP";
          ]
        ];
      ]
    ];
parseStream~SetAttributes~HoldFirst;


(* ::Subsubsubsection::Closed:: *)
(*ParseStream*)



Options[ParseStream]=
  {
    "ParseStrict"->True
    };
ParseStream[parser_, stream_]:=
  Module[
    {
      toks = parser["Lexer"]@"TokenStream"[stream],
      handlers = parser["Handlers"],
      ast = ASTObject[],
      state = <||>,
      stack = {},
      tree
      },
    Internal`WithLocalSettings[
      None,
      state["CurrentNode"] = ast["Tree"];
      state["BlockType"] = "Default";
      state["Precedence"] = -Infinity;
      parseStream[{stack, state, handlers}, TokenStreamer@toks];
      tree = state["CurrentNode"];
      If[(OptionValue["ParseStrict"]===False),
        tree =
          Fold[
            AddASTNodeData[
              #2,
              #
              ]&,
            tree
            ];
        stack = {};
        ];
      {
        stack,
        InterfaceModify[ASTObject, ast, ReplacePart[#, "Tree"->state["CurrentNode"]]&]
        },
      If[StringQ@stream, toks@"Close"[]]
      ]
    ]


Options[ApplyParser]=
  Options[ParseStream];
ApplyParser[parser_, stream_, ops:OptionsPattern[]]:=
  PackageExceptionBlock["Parse"]@
    Module[{stack, ast},
      {stack, ast}=
        Block[{LexerToken = ConstructLexToken}, 
          ParseStream[parser, stream, ops]
          ];
      If[Length@stack>0,
        PackageRaiseException[
          "Incomplete node at end of stream"
          ]
        ];
      ast
      ]


End[];



